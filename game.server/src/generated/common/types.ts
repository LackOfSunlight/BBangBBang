// @generated by protobuf-ts 2.11.1 with parameter long_type_string
// @generated from protobuf file "common/types.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CharacterStateType } from "./enums";
import { PhaseType } from "./enums";
import { CardType } from "./enums";
import { RoleType } from "./enums";
import { CharacterType } from "./enums";
import { RoomStateType } from "./enums";
/**
 *
 * 게임 데이터 명세
 *
 * @generated from protobuf message RoomData
 */
export interface RoomData {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: int64 ownerId = 2
     */
    ownerId: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: int32 maxUserNum = 4
     */
    maxUserNum: number;
    /**
     * @generated from protobuf field: RoomStateType state = 5
     */
    state: RoomStateType; // WAIT 0, PREPARE 1, INAGAME 2
    /**
     * @generated from protobuf field: repeated UserData users = 6
     */
    users: UserData[]; // 인덱스 기반으로 턴 진행
}
/**
 * 입장했을 때는 랜덤으로 체력만큼 카드 받음.
 * 하루 종료 시 체력만큼의 카드만 남길 수 있음.
 * 이후 낮이 될 때마다 카드를 두 장 받고 시작함.
 *
 * @generated from protobuf message UserData
 */
export interface UserData {
    /**
     * @generated from protobuf field: int64 id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string nickname = 2
     */
    nickname: string;
    /**
     * @generated from protobuf field: CharacterData character = 3
     */
    character?: CharacterData;
}
/**
 * @generated from protobuf message CharacterData
 */
export interface CharacterData {
    /**
     * @generated from protobuf field: CharacterType characterType = 1
     */
    characterType: CharacterType;
    /**
     * @generated from protobuf field: RoleType roleType = 2
     */
    roleType: RoleType;
    /**
     * @generated from protobuf field: int32 hp = 3
     */
    hp: number;
    /**
     * @generated from protobuf field: int32 weapon = 4
     */
    weapon: number;
    /**
     * @generated from protobuf field: CharacterStateInfoData stateInfo = 5
     */
    stateInfo?: CharacterStateInfoData;
    /**
     * @generated from protobuf field: repeated int32 equips = 6
     */
    equips: number[];
    /**
     * @generated from protobuf field: repeated int32 debuffs = 7
     */
    debuffs: number[];
    /**
     * @generated from protobuf field: repeated CardData handCards = 8
     */
    handCards: CardData[];
    /**
     * @generated from protobuf field: int32 bbangCount = 9
     */
    bbangCount: number;
    /**
     * @generated from protobuf field: int32 handCardsCount = 10
     */
    handCardsCount: number;
}
/**
 * @generated from protobuf message CharacterPositionData
 */
export interface CharacterPositionData {
    /**
     * @generated from protobuf field: int64 id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: double x = 2
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 3
     */
    y: number;
}
/**
 * @generated from protobuf message CardData
 */
export interface CardData {
    /**
     * @generated from protobuf field: CardType type = 1
     */
    type: CardType;
    /**
     * @generated from protobuf field: int32 count = 2
     */
    count: number;
}
/**
 * @generated from protobuf message GameStateData
 */
export interface GameStateData {
    /**
     * @generated from protobuf field: PhaseType phaseType = 1
     */
    phaseType: PhaseType; // DAY 1, EVENING 2, END 3 (하루 종료 시 카드 버리는 턴)
    /**
     * @generated from protobuf field: int64 nextPhaseAt = 2
     */
    nextPhaseAt: string; // 다음 페이즈 시작 시점(밀리초 타임스탬프)
}
/**
 * @generated from protobuf message CharacterStateInfoData
 */
export interface CharacterStateInfoData {
    /**
     * @generated from protobuf field: CharacterStateType state = 1
     */
    state: CharacterStateType;
    /**
     * @generated from protobuf field: CharacterStateType nextState = 2
     */
    nextState: CharacterStateType;
    /**
     * @generated from protobuf field: int64 nextStateAt = 3
     */
    nextStateAt: string; // state가 nextState로 풀리는 밀리초 타임스탬프. state가 NONE이면 0
    /**
     * @generated from protobuf field: int64 stateTargetUserId = 4
     */
    stateTargetUserId: string; // state에 target이 있을 경우
}
// @generated message type with reflection information, may provide speed optimized methods
class RoomData$Type extends MessageType<RoomData> {
    constructor() {
        super("RoomData", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "ownerId", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "maxUserNum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "state", kind: "enum", T: () => ["RoomStateType", RoomStateType] },
            { no: 6, name: "users", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserData }
        ]);
    }
    create(value?: PartialMessage<RoomData>): RoomData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.ownerId = "0";
        message.name = "";
        message.maxUserNum = 0;
        message.state = 0;
        message.users = [];
        if (value !== undefined)
            reflectionMergePartial<RoomData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomData): RoomData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* int64 ownerId */ 2:
                    message.ownerId = reader.int64().toString();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* int32 maxUserNum */ 4:
                    message.maxUserNum = reader.int32();
                    break;
                case /* RoomStateType state */ 5:
                    message.state = reader.int32();
                    break;
                case /* repeated UserData users */ 6:
                    message.users.push(UserData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* int64 ownerId = 2; */
        if (message.ownerId !== "0")
            writer.tag(2, WireType.Varint).int64(message.ownerId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* int32 maxUserNum = 4; */
        if (message.maxUserNum !== 0)
            writer.tag(4, WireType.Varint).int32(message.maxUserNum);
        /* RoomStateType state = 5; */
        if (message.state !== 0)
            writer.tag(5, WireType.Varint).int32(message.state);
        /* repeated UserData users = 6; */
        for (let i = 0; i < message.users.length; i++)
            UserData.internalBinaryWrite(message.users[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomData
 */
export const RoomData = new RoomData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData$Type extends MessageType<UserData> {
    constructor() {
        super("UserData", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "character", kind: "message", T: () => CharacterData }
        ]);
    }
    create(value?: PartialMessage<UserData>): UserData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "0";
        message.nickname = "";
        if (value !== undefined)
            reflectionMergePartial<UserData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData): UserData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toString();
                    break;
                case /* string nickname */ 2:
                    message.nickname = reader.string();
                    break;
                case /* CharacterData character */ 3:
                    message.character = CharacterData.internalBinaryRead(reader, reader.uint32(), options, message.character);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== "0")
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string nickname = 2; */
        if (message.nickname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nickname);
        /* CharacterData character = 3; */
        if (message.character)
            CharacterData.internalBinaryWrite(message.character, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserData
 */
export const UserData = new UserData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterData$Type extends MessageType<CharacterData> {
    constructor() {
        super("CharacterData", [
            { no: 1, name: "characterType", kind: "enum", T: () => ["CharacterType", CharacterType] },
            { no: 2, name: "roleType", kind: "enum", T: () => ["RoleType", RoleType] },
            { no: 3, name: "hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "weapon", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "stateInfo", kind: "message", T: () => CharacterStateInfoData },
            { no: 6, name: "equips", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "debuffs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "handCards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardData },
            { no: 9, name: "bbangCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "handCardsCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CharacterData>): CharacterData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.characterType = 0;
        message.roleType = 0;
        message.hp = 0;
        message.weapon = 0;
        message.equips = [];
        message.debuffs = [];
        message.handCards = [];
        message.bbangCount = 0;
        message.handCardsCount = 0;
        if (value !== undefined)
            reflectionMergePartial<CharacterData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterData): CharacterData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* CharacterType characterType */ 1:
                    message.characterType = reader.int32();
                    break;
                case /* RoleType roleType */ 2:
                    message.roleType = reader.int32();
                    break;
                case /* int32 hp */ 3:
                    message.hp = reader.int32();
                    break;
                case /* int32 weapon */ 4:
                    message.weapon = reader.int32();
                    break;
                case /* CharacterStateInfoData stateInfo */ 5:
                    message.stateInfo = CharacterStateInfoData.internalBinaryRead(reader, reader.uint32(), options, message.stateInfo);
                    break;
                case /* repeated int32 equips */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equips.push(reader.int32());
                    else
                        message.equips.push(reader.int32());
                    break;
                case /* repeated int32 debuffs */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.debuffs.push(reader.int32());
                    else
                        message.debuffs.push(reader.int32());
                    break;
                case /* repeated CardData handCards */ 8:
                    message.handCards.push(CardData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 bbangCount */ 9:
                    message.bbangCount = reader.int32();
                    break;
                case /* int32 handCardsCount */ 10:
                    message.handCardsCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* CharacterType characterType = 1; */
        if (message.characterType !== 0)
            writer.tag(1, WireType.Varint).int32(message.characterType);
        /* RoleType roleType = 2; */
        if (message.roleType !== 0)
            writer.tag(2, WireType.Varint).int32(message.roleType);
        /* int32 hp = 3; */
        if (message.hp !== 0)
            writer.tag(3, WireType.Varint).int32(message.hp);
        /* int32 weapon = 4; */
        if (message.weapon !== 0)
            writer.tag(4, WireType.Varint).int32(message.weapon);
        /* CharacterStateInfoData stateInfo = 5; */
        if (message.stateInfo)
            CharacterStateInfoData.internalBinaryWrite(message.stateInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 equips = 6; */
        if (message.equips.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.equips.length; i++)
                writer.int32(message.equips[i]);
            writer.join();
        }
        /* repeated int32 debuffs = 7; */
        if (message.debuffs.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.debuffs.length; i++)
                writer.int32(message.debuffs[i]);
            writer.join();
        }
        /* repeated CardData handCards = 8; */
        for (let i = 0; i < message.handCards.length; i++)
            CardData.internalBinaryWrite(message.handCards[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* int32 bbangCount = 9; */
        if (message.bbangCount !== 0)
            writer.tag(9, WireType.Varint).int32(message.bbangCount);
        /* int32 handCardsCount = 10; */
        if (message.handCardsCount !== 0)
            writer.tag(10, WireType.Varint).int32(message.handCardsCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CharacterData
 */
export const CharacterData = new CharacterData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterPositionData$Type extends MessageType<CharacterPositionData> {
    constructor() {
        super("CharacterPositionData", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<CharacterPositionData>): CharacterPositionData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "0";
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<CharacterPositionData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterPositionData): CharacterPositionData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toString();
                    break;
                case /* double x */ 2:
                    message.x = reader.double();
                    break;
                case /* double y */ 3:
                    message.y = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterPositionData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== "0")
            writer.tag(1, WireType.Varint).int64(message.id);
        /* double x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit64).double(message.x);
        /* double y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit64).double(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CharacterPositionData
 */
export const CharacterPositionData = new CharacterPositionData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CardData$Type extends MessageType<CardData> {
    constructor() {
        super("CardData", [
            { no: 1, name: "type", kind: "enum", T: () => ["CardType", CardType] },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CardData>): CardData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial<CardData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CardData): CardData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* CardType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CardData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* CardType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CardData
 */
export const CardData = new CardData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameStateData$Type extends MessageType<GameStateData> {
    constructor() {
        super("GameStateData", [
            { no: 1, name: "phaseType", kind: "enum", T: () => ["PhaseType", PhaseType] },
            { no: 2, name: "nextPhaseAt", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<GameStateData>): GameStateData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.phaseType = 0;
        message.nextPhaseAt = "0";
        if (value !== undefined)
            reflectionMergePartial<GameStateData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameStateData): GameStateData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* PhaseType phaseType */ 1:
                    message.phaseType = reader.int32();
                    break;
                case /* int64 nextPhaseAt */ 2:
                    message.nextPhaseAt = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameStateData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* PhaseType phaseType = 1; */
        if (message.phaseType !== 0)
            writer.tag(1, WireType.Varint).int32(message.phaseType);
        /* int64 nextPhaseAt = 2; */
        if (message.nextPhaseAt !== "0")
            writer.tag(2, WireType.Varint).int64(message.nextPhaseAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GameStateData
 */
export const GameStateData = new GameStateData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterStateInfoData$Type extends MessageType<CharacterStateInfoData> {
    constructor() {
        super("CharacterStateInfoData", [
            { no: 1, name: "state", kind: "enum", T: () => ["CharacterStateType", CharacterStateType] },
            { no: 2, name: "nextState", kind: "enum", T: () => ["CharacterStateType", CharacterStateType] },
            { no: 3, name: "nextStateAt", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "stateTargetUserId", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<CharacterStateInfoData>): CharacterStateInfoData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        message.nextState = 0;
        message.nextStateAt = "0";
        message.stateTargetUserId = "0";
        if (value !== undefined)
            reflectionMergePartial<CharacterStateInfoData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterStateInfoData): CharacterStateInfoData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* CharacterStateType state */ 1:
                    message.state = reader.int32();
                    break;
                case /* CharacterStateType nextState */ 2:
                    message.nextState = reader.int32();
                    break;
                case /* int64 nextStateAt */ 3:
                    message.nextStateAt = reader.int64().toString();
                    break;
                case /* int64 stateTargetUserId */ 4:
                    message.stateTargetUserId = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterStateInfoData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* CharacterStateType state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* CharacterStateType nextState = 2; */
        if (message.nextState !== 0)
            writer.tag(2, WireType.Varint).int32(message.nextState);
        /* int64 nextStateAt = 3; */
        if (message.nextStateAt !== "0")
            writer.tag(3, WireType.Varint).int64(message.nextStateAt);
        /* int64 stateTargetUserId = 4; */
        if (message.stateTargetUserId !== "0")
            writer.tag(4, WireType.Varint).int64(message.stateTargetUserId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CharacterStateInfoData
 */
export const CharacterStateInfoData = new CharacterStateInfoData$Type();
